"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalCalendarManager = void 0;
const collection_1 = require("@discordjs/collection");
const CacheableStructManager_1 = require("./CacheableStructManager");
const CalendarEvent_1 = require("../../structures/CalendarEvent");
class GlobalCalendarManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheCalendar() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheCalendars) !== false;
    }
    get shouldCacheCalendarRsvps() {
        var _a, _b;
        return ((_b = (_a = this.client.options) === null || _a === void 0 ? void 0 : _a.cache) === null || _b === void 0 ? void 0 : _b.cacheCalendarsRsvps) !== false;
    }
    /** Create a calendar event. */
    create(channelId, options) {
        return this.client.rest.router.createCalendarEvent(channelId, options).then((data) => {
            return new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
        });
    }
    /** Get a single calendar event. */
    fetch(channelId, calendarEventId, force) {
        if (!force) {
            const existingCalendar = this.client.calendars.cache.get(calendarEventId);
            if (existingCalendar)
                return Promise.resolve(existingCalendar);
        }
        return this.client.rest.router.getCalendarEvent(channelId, calendarEventId).then((data) => {
            const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
            if (this.shouldCacheCalendar)
                this.client.calendars.cache.set(newCalendar.id, newCalendar);
            return newCalendar;
        });
    }
    /** Get multiple calendar events. */
    fetchMany(channelId, options) {
        return this.client.rest.router.getCalendarEvents(channelId, options).then((data) => {
            const calendarEvents = new collection_1.Collection();
            for (const calendarEvent of data.calendarEvents) {
                const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, calendarEvent);
                calendarEvents.set(newCalendar.id, newCalendar);
                if (this.shouldCacheCalendar)
                    this.client.calendars.cache.set(newCalendar.id, newCalendar);
            }
            return calendarEvents;
        });
    }
    /** Update a calendar event. */
    update(channelId, calendarEventId, options) {
        return this.client.rest.router.updateCalendarEvent(channelId, calendarEventId, options).then((data) => {
            const existingCalendar = this.cache.get(calendarEventId);
            if (existingCalendar)
                return existingCalendar._update(data.calendarEvent);
            const newCalendar = new CalendarEvent_1.CalendarEvent(this.client, data.calendarEvent);
            if (this.shouldCacheCalendar)
                this.cache.set(newCalendar.id, newCalendar);
            return newCalendar;
        });
    }
    /** Delete a calendar event. */
    delete(channelId, calendarEventId) {
        return this.client.rest.router.deleteCalendarEvent(channelId, calendarEventId).then((data) => {
            const cachedCalendar = this.cache.get(calendarEventId);
            return cachedCalendar !== null && cachedCalendar !== void 0 ? cachedCalendar : void 0;
        });
    }
    /** Get a single rsvp from a caldenar event */
    fetchRsvp(channelId, calendarEventId, userId, force) {
        var _a, _b;
        if (!force) {
            const existingRsvp = (_b = (_a = this.client.calendars.cache.get(calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.get(userId);
            if (existingRsvp)
                return Promise.resolve(existingRsvp);
        }
        return this.client.rest.router.getCalendarEventRsvp(channelId, calendarEventId, userId).then((data) => {
            var _a, _b;
            const newRsvp = new CalendarEvent_1.CalendarEventRsvp(this.client, data.calendarEventRsvp);
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps)
                (_b = (_a = this.cache.get(newRsvp.calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.set(newRsvp.userId, newRsvp);
            return newRsvp;
        });
    }
    /** Fetch rsvps for a calendar event */
    fetchManyRsvps(channelId, calendarEventId) {
        return this.client.rest.router.getCalendarEventRsvps(channelId, calendarEventId).then((data) => {
            var _a;
            const rsvpEvents = new collection_1.Collection();
            for (const rsvpEvent of data.calendarEventRsvps) {
                if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps) {
                    const cachedCalendar = this.cache.get(calendarEventId);
                    (_a = cachedCalendar === null || cachedCalendar === void 0 ? void 0 : cachedCalendar.rsvps) === null || _a === void 0 ? void 0 : _a.set(rsvpEvent.userId, new CalendarEvent_1.CalendarEventRsvp(this.client, rsvpEvent));
                }
                rsvpEvents.set(rsvpEvent.userId, new CalendarEvent_1.CalendarEventRsvp(this.client, rsvpEvent));
            }
            return rsvpEvents;
        });
    }
    /** Create or update an rsvp for a calendar event */
    updateRsvp(channelId, calendarEventId, userId, options) {
        return this.client.rest.router.updateCalendarEventRvsp(channelId, calendarEventId, userId, options).then((data) => {
            var _a, _b, _c, _d;
            const existingRsvp = (_b = (_a = this.cache.get(calendarEventId)) === null || _a === void 0 ? void 0 : _a.rsvps) === null || _b === void 0 ? void 0 : _b.get(userId);
            if (existingRsvp)
                return existingRsvp === null || existingRsvp === void 0 ? void 0 : existingRsvp._update(data.calendarEventRsvp);
            const newRsvp = new CalendarEvent_1.CalendarEventRsvp(this.client, data.calendarEventRsvp);
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps)
                (_d = (_c = this.cache.get(calendarEventId)) === null || _c === void 0 ? void 0 : _c.rsvps) === null || _d === void 0 ? void 0 : _d.set(userId, newRsvp);
            return newRsvp;
        });
    }
    /** Delete an rsvp for a calendar event */
    deleteRsvp(channelId, calendarEventId, userId) {
        return this.client.rest.router.deleteCalendarEventRvsp(channelId, calendarEventId, userId).then((data) => {
            var _a;
            if (this.shouldCacheCalendar && this.shouldCacheCalendarRsvps) {
                const cachedCalendar = this.cache.get(calendarEventId);
                const rsvp = (_a = cachedCalendar === null || cachedCalendar === void 0 ? void 0 : cachedCalendar.rsvps) === null || _a === void 0 ? void 0 : _a.get(userId);
                return rsvp !== null && rsvp !== void 0 ? rsvp : void 0;
            }
            return void 0;
        });
    }
}
exports.GlobalCalendarManager = GlobalCalendarManager;
//# sourceMappingURL=CalendarManager.js.map