"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalMessageManager = void 0;
const Message_1 = require("../../structures/Message");
const CacheableStructManager_1 = require("./CacheableStructManager");
const collection_1 = require("@discordjs/collection");
const util_1 = require("../../util");
const structures_1 = require("../../structures");
class GlobalMessageManager extends CacheableStructManager_1.CacheableStructManager {
    get shouldCacheMessage() {
        var _a;
        return ((_a = this.client.options.cache) === null || _a === void 0 ? void 0 : _a.cacheMessages) !== false;
    }
    /** Get a list of the latest 50 messages from a channel. */
    fetchMany(channelId, options) {
        return this.client.rest.router.getChannelMessages(channelId, options).then((data) => {
            const messages = new collection_1.Collection();
            for (const message of data.messages) {
                const newMessage = new Message_1.Message(this.client, message);
                messages.set(newMessage.id, newMessage);
            }
            return messages;
        });
    }
    /** Get details for a specific chat message from a chat channel. */
    fetch(channelId, messageId, force) {
        if (!force) {
            const existingMessage = this.client.messages.cache.get(messageId);
            if (existingMessage)
                return Promise.resolve(existingMessage);
        }
        return this.client.rest.router.getChannelMessage(channelId, messageId).then((data) => {
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Send a message in a channel */
    send(channelId, content) {
        return this.client.rest.router.createChannelMessage(channelId, (0, util_1.resolveContentToData)(content)).then((data) => {
            // This is in the case of which the WS gateway beats us to adding the message to the cache. If they haven't, then we do it ourselves.
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage;
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Add a reaction emote */
    addReaction(channelId, contentId, emoteId) {
        return this.client.rest.router.addReactionEmote(channelId, contentId, emoteId).then(() => void 0);
    }
    /** Delete a reaction emote */
    deleteReaction(channelId, contentId, emoteId) {
        return this.client.rest.router.deleteReactionEmote(channelId, contentId, emoteId).then(() => void 0);
    }
    /** Update a channel message. */
    update(channelId, messageId, content) {
        return this.client.rest.router.updateChannelMessage(channelId, messageId, (0, util_1.resolveContentToData)(content)).then((data) => {
            // This is in the case of which the WS gateway beats us to modifying the message in the cache. If they haven't, then we do it ourselves.
            const existingMessage = this.client.messages.cache.get(data.message.id);
            if (existingMessage)
                return existingMessage._update(data.message);
            const newMessage = new Message_1.Message(this.client, data.message);
            this.client.messages.cache.set(newMessage.id, newMessage);
            return newMessage;
        });
    }
    /** Delete a channel message. */
    delete(channelId, messageId) {
        return this.client.rest.router.deleteChannelMessage(channelId, messageId).then(() => void 0);
    }
    awaitMessages(channelId, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new structures_1.MessageCollector(this.client, Object.assign(Object.assign({}, options), { filter: (item) => {
                    var _a, _b;
                    if (item.channelId !== channelId)
                        return false;
                    return (_b = (_a = options.filter) === null || _a === void 0 ? void 0 : _a.call(options, item)) !== null && _b !== void 0 ? _b : true;
                } })).start();
        });
    }
}
exports.GlobalMessageManager = GlobalMessageManager;
//# sourceMappingURL=MessageManager.js.map