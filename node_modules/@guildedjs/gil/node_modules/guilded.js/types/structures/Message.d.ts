import type { ChatMessagePayload, RESTPostChannelMessagesBody, MentionsPayload, WSChannelMessageReactionCreatedPayload, EmotePayload } from "@guildedjs/guilded-api-typings";
import type { Client } from "./Client";
import { Base } from "./Base";
import type { User } from "./User";
import type { Member } from "./Member";
import { Embed } from "./Embed";
import type { Channel } from "./channels";
import type { MessageContent } from "../typings";
export declare enum MessageType {
    Default = 0,
    System = 1
}
export declare class Message extends Base<ChatMessagePayload> {
    /** The ID of the channel */
    readonly channelId: string;
    /** The ID of the server this message belongs to */
    readonly serverId: string | null;
    /** The type of chat message. "system" messages are generated by Guilded, while "default" messages are user or bot-generated. */
    readonly type: MessageType;
    /** The content of the message */
    content: string;
    /** The mentions within this message */
    mentions?: MentionsPayload;
    /** The ID of the messages that this is replying to. */
    readonly replyMessageIds: string[];
    /** If set, this message will only be seen by those mentioned or replied to. */
    readonly isPrivate: boolean;
    /** If set, this message did not notify, mention or reply recipients. */
    readonly isSilent: boolean;
    /** The ID of the user who created this message (Note: If this event has createdByBotId or createdByWebhookId present, this field will still be populated, but can be ignored. In these cases, the value of this field will always be Ann6LewA) */
    readonly createdById: string;
    /** The ID of the bot who created this message, if it was created by a bot */
    readonly createdByBotId: string | null;
    /** The ID of the webhook who created this message, if it was created by a webhook */
    readonly createdByWebhookId: string | null;
    /** The timestamp that the message was created at. */
    readonly _createdAt: number;
    /** The timestamp that the message was updated at, if relevant */
    _updatedAt: number | null;
    /** Whether the message has been deleted */
    deleted: boolean;
    /** When the message was deleted, if it was */
    _deletedAt: number | null;
    constructor(client: Client, data: ChatMessagePayload);
    get createdAt(): Date;
    get updatedAt(): Date | null;
    get deletedAt(): Date | null;
    /** Update details of this structure */
    _update(data: Partial<ChatMessagePayload> | {
        deletedAt: string;
    }): this;
    /** Get the author of this message */
    get author(): User | null;
    /** The author id of the user who sent this message. */
    get authorId(): string;
    /** Get the member of this message (if in server) */
    get member(): Member | null;
    /** Get the channel of this message */
    get channel(): Channel | null;
    edit(newContent: RESTPostChannelMessagesBody | Embed | string): Promise<Message>;
    /** Send a message in the same channel as this message. */
    send(content: MessageContent): Promise<Message>;
    /** Send a message that replies to this message. It mentions the user who sent this message. */
    reply(content: MessageContent): Promise<Message>;
    /** Add a reaction emote */
    addReaction(emoteId: number): Promise<void>;
    /** Delete a reaction emote */
    deleteReaction(emoteId: number): Promise<void>;
    /** Delete this message. */
    delete(): Promise<void>;
}
export declare class MessageReaction extends Base<FlattenedReactionData> {
    readonly channelId: string;
    readonly messageId: string;
    readonly createdBy: string;
    readonly emote: EmotePayload;
    readonly serverId: string;
    constructor(client: Client, data: FlattenedReactionData);
}
declare type FlattenedReactionData = WSChannelMessageReactionCreatedPayload["d"]["reaction"] & {
    serverId: string;
};
export {};
//# sourceMappingURL=Message.d.ts.map