/// <reference types="node" />
import { Collection } from "@discordjs/collection";
import type { MaybePromise } from "../../typings";
import type { Client } from "../Client";
export declare abstract class Collector<T extends CollectableStructure> {
    readonly client: Client;
    options: Partial<CollectorOptions<T>>;
    /** successfully collected entries */
    readonly entries: Collection<T["id"], T>;
    /** whether the collector is actively collecting elements */
    isActive: boolean;
    /** method to resolve the promise this collector has when instantiated */
    protected resolve: ((value: CollectorReturnValue<T>) => void) | null;
    /** timeout for max time */
    protected maxTimeout: NodeJS.Timeout | null;
    /** bound function for item receiving */
    protected boundItemReceiver: (entry: T) => Promise<boolean>;
    constructor(client: Client, options: Partial<CollectorOptions<T>>);
    start(): Promise<CollectorReturnValue<T>>;
    itemReceived(entry: T): Promise<boolean>;
    protected incrementMaxEventListeners(): number;
    protected decrementMaxEventListeners(): number;
    abstract hookEvents(): void;
    abstract _cleanup(): void;
}
export declare enum CollectorEndReasons {
    MAX = "MAX_AMOUNT",
    TIME = "TIME_EXPIRED"
}
declare type CollectorReturnValue<T extends CollectableStructure> = {
    reason: CollectorEndReasons;
    entries: Collection<T["id"], T>;
};
declare type CollectableStructure = {
    id: string;
};
export interface CollectorOptions<T> {
    /** a function that determines whether an entry is collected or not */
    filter?: (item: T) => MaybePromise<boolean>;
    /** the max amount of time this collector run for before exiting (ms) */
    timeLimit: number;
    /** the max amount of entries allowed to be collected */
    max?: number;
}
export {};
//# sourceMappingURL=Collector.d.ts.map